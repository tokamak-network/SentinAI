# Proposal 4: AI Cost Optimizer - Implementation Specification

> Creation date: 2026-02-06
> Target audience: Claude Opus 4.6 Implementation Agent
> Goal: Enable functionality to be implemented from start to finish using only this document

---

## index

1. [Overview](#1-Overview)
2. [Type Definition](#2-Type-Definition)
3. [New file specification](#3-new-file-specification)
4. [Edit existing file](#4-Existing-file-Edit)
5. [API specification](#5-api-specification)
6. [AI Prompt Full Text](#6-ai-Prompt-Full Text)
7. [Environment Variables](#7-Environment-Variables)
8. [Test Verification](#8-Test-Verification)
9. [Dependency](#9-Dependency)
10. [UI Details - Usage Heatmap](#10-ui-Details---usage-heatmap)

---

## 1. Overview

### 1.1 Function description

**AI Cost Optimizer** is a feature that automatically identifies cost-saving opportunities and provides AI-based recommendations by analyzing vCPU usage patterns of Optimism L2 nodes.

**Key Features:**
- Track vCPU usage patterns over time (7 days)
- Visualize usage patterns with day x time heatmap
- Generate cost-optimized recommendations with Claude AI
- Present expected savings and implementation methods

### 1.2 Current system limitations

Currently cost calculations in `src/app/api/metrics/route.ts` are based on a static formula:

```typescript
// Current approach: assumes a fixed average usage pattern
const avgVcpu = 0.7 * 1 + 0.2 * 2 + 0.1 * 4; // 1.5 vCPU Average
const dynamicMonthlyCost = (avgVcpu * FARGATE_VCPU_HOUR + avgMemory * FARGATE_MEM_GB_HOUR) * HOURS_PER_MONTH;
```

**Problem:**
- No pattern analysis by actual time zone (same resource allocation even in the early morning)
- No comparison between Reserved vs On-Demand
- No scaling history based optimization
- No actual cost vs optimal cost gap analysis

### 1.3 Dependencies

| Depends on | Description | status |
|-----------|------|------|
| MetricsStore (P1) | Time series metrics store. Utilizing the `getStats()` function | Implementation required in Proposal 1 |
| ScalingHistory | Check scaling history. `getScalingHistory()` function | Existing in existing `k8s-scaler.ts` |
| AI Gateway | Claude API call | Existing pattern exists (`ai-analyzer.ts`) |

**Independent:** Can be implemented independently of Proposal 2, 3, and 5

---

## 2. Type definition

### 2.1 Create file: `src/types/cost.ts`

```typescript
/**
 * AI Cost Optimizer Types
* Type definition for analyzing vCPU usage patterns and recommending cost optimization
 */

/**
* Usage patterns by time zone
* Statistics for each cell in the 7-day x 24-hour matrix
 */
export interface UsagePattern {
/** Time (0-23) */
  hourOfDay: number;
/** Day of the week (0=Sunday, 1=Monday, ..., 6=Saturday) */
  dayOfWeek: number;
/** Average vCPU for that time period */
  avgVcpu: number;
/** Maximum vCPU for that time period */
  peakVcpu: number;
/** Average CPU utilization for that time period (0-100) */
  avgUtilization: number;
/** Number of samples collected during that time period */
  sampleCount: number;
}

/**
* Cost optimization recommendations
 */
export interface CostRecommendation {
/** Recommendation type */
  type: 'downscale' | 'schedule' | 'reserved' | 'right-size';
/** Recommended title (Korean) */
  title: string;
/** Detailed description (Korean) */
  description: string;
/** Current monthly cost (USD) */
  currentCost: number;
/** Estimated monthly cost after application (USD) */
  projectedCost: number;
/** Savings rate (0-100) */
  savingsPercent: number;
/** AI recommendation confidence (0-1) */
  confidence: number;
/** Description of implementation method (Korean) */
  implementation: string;
/** Risk */
  risk: 'low' | 'medium' | 'high';
}

/**
* Cost analysis report
 */
export interface CostReport {
/** Report unique ID (UUID) */
  id: string;
/** Creation time (ISO 8601) */
  generatedAt: string;
/** Current estimated monthly cost (USD) */
  currentMonthly: number;
/** Estimated monthly cost after optimization (USD) */
  optimizedMonthly: number;
/** Total savings (0-100) */
  totalSavingsPercent: number;
/** Recommended list */
  recommendations: CostRecommendation[];
/** Usage patterns by time zone (7x24=168) */
  usagePatterns: UsagePattern[];
/** Natural language insights generated by AI (Korean) */
  aiInsight: string;
/** Analysis period (days) */
  periodDays: number;
}

/**
* Usage data points (for internal storage)
 */
export interface UsageDataPoint {
  /** Unix timestamp (ms) */
  timestamp: number;
/** vCPU allocated */
  vcpu: number;
/** CPU utilization (0-100) */
  cpuUtilization: number;
}

/**
* 24-hour profile (summary by time zone)
 */
export interface HourlyProfile {
/** Time (0-23) */
  hour: number;
/** Average vCPU */
  avgVcpu: number;
/** Average CPU utilization */
  avgUtilization: number;
}

/**
* Cost calculation constants
 */
export const FARGATE_PRICING = {
/** Cost per vCPU hour (USD) - Seoul Region */
  vcpuPerHour: 0.04656,
/** Cost per GB of memory (USD) - Seoul region */
  memGbPerHour: 0.00511,
/** Region */
  region: 'ap-northeast-2' as const,
} as const;

/**
* time constant
 */
export const TIME_CONSTANTS = {
/** Monthly Time */
  HOURS_PER_MONTH: 730,
/** Daily time */
  HOURS_PER_DAY: 24,
/** Number of days per week */
  DAYS_PER_WEEK: 7,
/** Milliseconds per minute */
  MS_PER_MINUTE: 60 * 1000,
/** Milliseconds per day */
  MS_PER_DAY: 24 * 60 * 60 * 1000,
} as const;

/**
* Labels for each recommendation type (for UI display)
 */
export const RECOMMENDATION_TYPE_LABELS: Record<CostRecommendation['type'], string> = {
downscale: 'Reduce resources',
schedule: 'Time-based scheduling',
reserved: 'reserved instance',
'right-size': 'Right sizing',
} as const;

/**
* Style by risk level (for UI display)
 */
export const RISK_STYLES: Record<CostRecommendation['risk'], { bg: string; text: string; label: string }> = {
low: { bg: 'bg-green-100', text: 'text-green-700', label: '낮음' },
medium: { bg: 'bg-yellow-100', text: 'text-yellow-700', label: '중간' },
high: { bg: 'bg-red-100', text: 'text-red-700', label: '높음' },
} as const;
```

---

## 3. New file specification

### 3.1 Create file: `src/lib/usage-tracker.ts`

A module that tracks and analyzes vCPU usage patterns.

```typescript
/**
 * Usage Tracker Module
* Track vCPU usage patterns and use them for cost optimization analysis
 */

import {
  UsageDataPoint,
  UsagePattern,
  HourlyProfile,
  TIME_CONSTANTS,
} from '@/types/cost';

// ============================================================
// In-Memory Storage
// ============================================================

/**
* Usage data storage
* - Data retention for up to 7 days
* - Up to 10,080 items collected at 1-minute intervals (7 * 24 * 60)
 */
const MAX_DATA_POINTS = 10080;
let usageData: UsageDataPoint[] = [];

/**
* Determine whether to enable tracking with environment variables
 */
function isTrackingEnabled(): boolean {
  return process.env.COST_TRACKING_ENABLED !== 'false';
}

// ============================================================
// Data Collection
// ============================================================

/**
* Record usage data
 *
* @param vcpu - Currently allocated vCPU (1, 2, 4, 8, etc.)
* @param cpuUtilization - Current CPU utilization (0-100)
 *
 * @example
 * ```typescript
* // Called from metrics API
 * recordUsage(currentVcpu, effectiveCpu);
 * ```
 */
export function recordUsage(vcpu: number, cpuUtilization: number): void {
  if (!isTrackingEnabled()) {
    return;
  }

// Excluding simulation data in stress test mode (if vcpu is 8)
// In actual operation, 8 vCPU is also possible, so modify this condition if necessary
  if (vcpu === 8) {
    return;
  }

  const dataPoint: UsageDataPoint = {
    timestamp: Date.now(),
    vcpu,
cpuUtilization: Math.min(Math.max(cpuUtilization, 0), 100), // clamp to range 0-100
  };

  usageData.push(dataPoint);

// Remove old data when maximum size is exceeded
  if (usageData.length > MAX_DATA_POINTS) {
    usageData = usageData.slice(-MAX_DATA_POINTS);
  }
}

/**
* View usage data for a specified period
 *
* @param days - Number of days to search
* @returns an array of UsageDataPoint for the period.
 */
export function getUsageData(days: number): UsageDataPoint[] {
  const cutoff = Date.now() - days * TIME_CONSTANTS.MS_PER_DAY;
  return usageData.filter((point) => point.timestamp >= cutoff);
}

/**
* View total usage data count (for debugging)
 */
export function getUsageDataCount(): number {
  return usageData.length;
}

/**
* Initialize usage data (for testing)
 */
export function clearUsageData(): void {
  usageData = [];
}

// ============================================================
// Pattern Analysis
// ============================================================

/**
* Analysis of usage patterns by time zone
 *
* Calculate statistics by grouping into 7 days x 24 hours = 168 buckets
 *
* @param days - Number of days to analyze, default 7
* @returns UsagePattern array (maximum 168)
 *
 * @example
 * ```typescript
 * const patterns = analyzePatterns(7);
* // Monday 10:00 AM pattern
 * const mondayMorning = patterns.find(p => p.dayOfWeek === 1 && p.hourOfDay === 10);
* console.log(`평그 vCPU: ${mondayMorning?.avgVcpu}`);
 * ```
 */
export function analyzePatterns(days: number = 7): UsagePattern[] {
  const data = getUsageData(days);

  if (data.length === 0) {
    return [];
  }

// Initialize bucket: [dayOfWeek][hourOfDay] = { vcpuSum, vcpuMax, utilSum, count }
  type Bucket = {
    vcpuSum: number;
    vcpuMax: number;
    utilSum: number;
    count: number;
  };

  const buckets: Map<string, Bucket> = new Map();

// Sort data into buckets
  for (const point of data) {
    const date = new Date(point.timestamp);
    const dayOfWeek = date.getDay(); // 0=Sun, 1=Mon, ..., 6=Sat
    const hourOfDay = date.getHours(); // 0-23
    const key = `${dayOfWeek}-${hourOfDay}`;

    const bucket = buckets.get(key) || {
      vcpuSum: 0,
      vcpuMax: 0,
      utilSum: 0,
      count: 0,
    };

    bucket.vcpuSum += point.vcpu;
    bucket.vcpuMax = Math.max(bucket.vcpuMax, point.vcpu);
    bucket.utilSum += point.cpuUtilization;
    bucket.count += 1;

    buckets.set(key, bucket);
  }

// Convert bucket to UsagePattern
  const patterns: UsagePattern[] = [];

  buckets.forEach((bucket, key) => {
    const [dayStr, hourStr] = key.split('-');
    const dayOfWeek = parseInt(dayStr, 10);
    const hourOfDay = parseInt(hourStr, 10);

    patterns.push({
      dayOfWeek,
      hourOfDay,
      avgVcpu: Math.round((bucket.vcpuSum / bucket.count) * 100) / 100,
      peakVcpu: bucket.vcpuMax,
      avgUtilization: Math.round((bucket.utilSum / bucket.count) * 100) / 100,
      sampleCount: bucket.count,
    });
  });

// Sort: Day of the week → Time order
  patterns.sort((a, b) => {
    if (a.dayOfWeek !== b.dayOfWeek) {
      return a.dayOfWeek - b.dayOfWeek;
    }
    return a.hourOfDay - b.hourOfDay;
  });

  return patterns;
}

/**
* Create 24-hour profile (regardless of day of the week)
 *
* Calculate hourly average by combining data from the same time zone for all days of the week
 *
* @returns 24 HourlyProfiles
 */
export function getHourlyBreakdown(): HourlyProfile[] {
const data = getUsageData(7); // Last 7 days data

  if (data.length === 0) {
// If there is no data, return default value
    return Array.from({ length: 24 }, (_, hour) => ({
      hour,
      avgVcpu: 1,
      avgUtilization: 0,
    }));
  }

// Accumulated by time
  const hourlyBuckets: Array<{ vcpuSum: number; utilSum: number; count: number }> =
    Array.from({ length: 24 }, () => ({ vcpuSum: 0, utilSum: 0, count: 0 }));

  for (const point of data) {
    const hour = new Date(point.timestamp).getHours();
    hourlyBuckets[hour].vcpuSum += point.vcpu;
    hourlyBuckets[hour].utilSum += point.cpuUtilization;
    hourlyBuckets[hour].count += 1;
  }

  return hourlyBuckets.map((bucket, hour) => ({
    hour,
    avgVcpu: bucket.count > 0
      ? Math.round((bucket.vcpuSum / bucket.count) * 100) / 100
      : 1,
    avgUtilization: bucket.count > 0
      ? Math.round((bucket.utilSum / bucket.count) * 100) / 100
      : 0,
  }));
}

/**
* Summary statistics on usage patterns
 *
* @param days - analysis period
* @returns summary statistics
 */
export function getUsageSummary(days: number = 7): {
  avgVcpu: number;
  peakVcpu: number;
  avgUtilization: number;
  dataPointCount: number;
  oldestDataAge: number; // hours
} {
  const data = getUsageData(days);

  if (data.length === 0) {
    return {
      avgVcpu: 1,
      peakVcpu: 1,
      avgUtilization: 0,
      dataPointCount: 0,
      oldestDataAge: 0,
    };
  }

  let vcpuSum = 0;
  let peakVcpu = 0;
  let utilSum = 0;

  for (const point of data) {
    vcpuSum += point.vcpu;
    peakVcpu = Math.max(peakVcpu, point.vcpu);
    utilSum += point.cpuUtilization;
  }

  const oldestTimestamp = data[0].timestamp;
  const oldestDataAge = (Date.now() - oldestTimestamp) / (1000 * 60 * 60); // hours

  return {
    avgVcpu: Math.round((vcpuSum / data.length) * 100) / 100,
    peakVcpu,
    avgUtilization: Math.round((utilSum / data.length) * 100) / 100,
    dataPointCount: data.length,
    oldestDataAge: Math.round(oldestDataAge * 10) / 10,
  };
}
```

---

### 3.2 Create file: `src/lib/cost-optimizer.ts`

AI-based cost analysis and recommendation generation module.

```typescript
/**
 * AI Cost Optimizer Module
* Cost optimization analysis and recommendation generation using Claude AI
 */

import {
  UsagePattern,
  CostRecommendation,
  CostReport,
  FARGATE_PRICING,
  TIME_CONSTANTS,
} from '@/types/cost';
import { ScalingHistoryEntry } from '@/types/scaling';
import { analyzePatterns, getUsageSummary } from './usage-tracker';
import { getScalingHistory } from './k8s-scaler';

// ============================================================
// AI Gateway Configuration
// ============================================================

const AI_GATEWAY_URL = process.env.AI_GATEWAY_URL || 'https://api.ai.tokamak.network';
const API_KEY = process.env.ANTHROPIC_API_KEY || '';

// ============================================================
// Cost Calculation Utilities
// ============================================================

/**
* Calculate monthly cost given average vCPU
 *
* @param avgVcpu - average vCPU
* @returns Monthly Cost (USD)
 */
export function calculateMonthlyCost(avgVcpu: number): number {
  const memoryGiB = avgVcpu * 2; // Memory = vCPU * 2
  const hourlyCost =
    avgVcpu * FARGATE_PRICING.vcpuPerHour +
    memoryGiB * FARGATE_PRICING.memGbPerHour;

  return Math.round(hourlyCost * TIME_CONSTANTS.HOURS_PER_MONTH * 100) / 100;
}

/**
* Monthly cost per fixed 4 vCPU (baseline)
 */
export function getBaselineMonthlyCost(): number {
  return calculateMonthlyCost(4);
}

/**
* Calculate estimated monthly cost when applying recommendations
 *
* @param recommendations - List of recommendations to apply
* @returns monthly cost after total estimated savings
 */
export function calculateProjectedCost(recommendations: CostRecommendation[]): number {
  if (recommendations.length === 0) {
    return getBaselineMonthlyCost();
  }

// Return the lowest projectedCost (since recommendations may overlap)
  const lowestProjected = Math.min(...recommendations.map(r => r.projectedCost));
  return lowestProjected;
}

// ============================================================
// AI Integration
// ============================================================

/**
* System messages for AI prompts
 */
const SYSTEM_PROMPT = `You are a cloud cost optimization advisor for an Optimism L2 Rollup infrastructure running on AWS Fargate.

## Your Role
Analyze vCPU usage patterns and scaling history to identify cost optimization opportunities.

## Infrastructure Context
- Platform: AWS Fargate (Seoul Region: ap-northeast-2)
- Pricing:
  - vCPU: $0.04656 per hour
  - Memory: $0.00511 per GB-hour
  - Memory allocation: vCPU * 2 GiB (e.g., 2 vCPU = 4 GiB)
- vCPU Range: 1-4 vCPU (dynamic scaling)
- Baseline comparison: Fixed 4 vCPU = ~$166/month

## Optimism L2 Workload Characteristics
- Batcher submits batches every 2-5 minutes
- Sequencer produces blocks every 2 seconds
- Traffic patterns: typically lower on weekends and night hours (KST)
- Peak hours: weekday business hours (9am-6pm KST)

## Recommendation Types
1. **downscale**: Reduce max vCPU or adjust idle thresholds
2. **schedule**: Time-based scaling (e.g., 1 vCPU at night, 2 vCPU during day)
3. **reserved**: Compare with Savings Plans or Reserved Capacity
4. **right-size**: Adjust current allocation based on actual usage

## Response Requirements
- All text descriptions should be in Korean
- Be specific about implementation steps
- Include risk assessment for each recommendation
- Calculate exact USD savings based on provided pricing

Respond ONLY in valid JSON format without markdown code blocks.`;

/**
* Create user prompt templates
 */
function buildUserPrompt(
  patterns: UsagePattern[],
  scalingHistory: ScalingHistoryEntry[],
  summary: { avgVcpu: number; peakVcpu: number; avgUtilization: number; dataPointCount: number },
  days: number
): string {
// Format patterns by time zone to make them easier to read
  const patternSummary = patterns.map(p => ({
    day: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][p.dayOfWeek],
    hour: p.hourOfDay,
    avgVcpu: p.avgVcpu,
    peakVcpu: p.peakVcpu,
    utilization: p.avgUtilization,
    samples: p.sampleCount,
  }));

// Summary of scaling history
  const historyEvents = scalingHistory.slice(0, 20).map(entry => ({
    time: entry.timestamp,
    from: entry.fromVcpu,
    to: entry.toVcpu,
    reason: entry.reason,
    trigger: entry.triggeredBy,
  }));

// calculate current cost
  const currentMonthlyCost = calculateMonthlyCost(summary.avgVcpu);
  const baselineCost = getBaselineMonthlyCost();

  return `## Analysis Period
${days} days of usage data, ${summary.dataPointCount} data points collected.

## Usage Summary
- Average vCPU: ${summary.avgVcpu}
- Peak vCPU: ${summary.peakVcpu}
- Average CPU Utilization: ${summary.avgUtilization}%

## Current Monthly Cost (based on average)
$${currentMonthlyCost.toFixed(2)}/month

## Baseline Comparison (Fixed 4 vCPU)
$${baselineCost.toFixed(2)}/month

## Time-based Usage Patterns (Day x Hour)
${JSON.stringify(patternSummary, null, 2)}

## Recent Scaling Events
${JSON.stringify(historyEvents, null, 2)}

## Instructions
Analyze the above data and provide cost optimization recommendations.

For each recommendation, include:
1. type: 'downscale' | 'schedule' | 'reserved' | 'right-size'
2. title: Recommended title (Korean, within 20 characters)
3. description: Detailed description (Korean, within 100 characters)
4. currentCost: Current monthly cost (USD)
5. projectedCost: Estimated monthly cost after application (USD)
6. savingsPercent: savings percentage (0-100)
7. confidence: confidence (0-1)
8. implementation: implementation method (Korean, in detail)
9. risk: 'low' | 'medium' | 'high'

Also provide an overall insight summary in Korean.

Respond in this exact JSON format:
{
  "recommendations": [
    {
      "type": "schedule",
      "title": "...",
      "description": "...",
      "currentCost": 123.45,
      "projectedCost": 98.76,
      "savingsPercent": 20,
      "confidence": 0.85,
      "implementation": "...",
      "risk": "low"
    }
  ],
"insight": "Full Insight Summary (Korean)"
}`;
}

/**
* Request AI to generate recommendations
 */
async function getAIRecommendations(
  patterns: UsagePattern[],
  scalingHistory: ScalingHistoryEntry[],
  summary: { avgVcpu: number; peakVcpu: number; avgUtilization: number; dataPointCount: number },
  days: number
): Promise<{ recommendations: CostRecommendation[]; insight: string }> {
  const userPrompt = buildUserPrompt(patterns, scalingHistory, summary, days);

  try {
    const response = await fetch(`${AI_GATEWAY_URL}/v1/chat/completions`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${API_KEY}`,
      },
      body: JSON.stringify({
        model: 'claude-haiku-4.5',
        messages: [
          { role: 'system', content: SYSTEM_PROMPT },
          { role: 'user', content: userPrompt },
        ],
        temperature: 0.2,
      }),
    });

    if (!response.ok) {
      throw new Error(`AI Gateway responded with ${response.status}: ${response.statusText}`);
    }

    const data = await response.json();
    const content = data.choices?.[0]?.message?.content || data.output || '{}';

// JSON parsing (removing markdown code blocks)
    const jsonStr = content.replace(/```json/g, '').replace(/```/g, '').trim();
    const parsed = JSON.parse(jsonStr);

// Verify response
    const recommendations: CostRecommendation[] = (parsed.recommendations || []).map((r: Record<string, unknown>) => ({
      type: validateRecommendationType(r.type as string),
title: String(r.title || 'Recommendations'),
      description: String(r.description || ''),
      currentCost: Number(r.currentCost) || calculateMonthlyCost(summary.avgVcpu),
      projectedCost: Number(r.projectedCost) || calculateMonthlyCost(summary.avgVcpu),
      savingsPercent: Math.min(Math.max(Number(r.savingsPercent) || 0, 0), 100),
      confidence: Math.min(Math.max(Number(r.confidence) || 0.5, 0), 1),
      implementation: String(r.implementation || ''),
      risk: validateRisk(r.risk as string),
    }));

const insight = String(parsed.insight || 'Data analysis completed.');

    return { recommendations, insight };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('[Cost Optimizer] AI Gateway Error:', errorMessage);

// Fallback: Generate default recommendation
    return generateFallbackRecommendations(summary, days);
  }
}

/**
* Verification of recommendation type
 */
function validateRecommendationType(type: string): CostRecommendation['type'] {
  const validTypes: CostRecommendation['type'][] = ['downscale', 'schedule', 'reserved', 'right-size'];
  if (validTypes.includes(type as CostRecommendation['type'])) {
    return type as CostRecommendation['type'];
  }
  return 'right-size';
}

/**
* Risk verification
 */
function validateRisk(risk: string): CostRecommendation['risk'] {
  const validRisks: CostRecommendation['risk'][] = ['low', 'medium', 'high'];
  if (validRisks.includes(risk as CostRecommendation['risk'])) {
    return risk as CostRecommendation['risk'];
  }
  return 'medium';
}

/**
* Generate fallback recommendation (in case of AI failure)
 */
function generateFallbackRecommendations(
  summary: { avgVcpu: number; peakVcpu: number; avgUtilization: number; dataPointCount: number },
  days: number
): { recommendations: CostRecommendation[]; insight: string } {
  const recommendations: CostRecommendation[] = [];
  const currentCost = calculateMonthlyCost(summary.avgVcpu);

// Recommend scaling down if average utilization is low
  if (summary.avgUtilization < 30 && summary.avgVcpu > 1) {
    const projectedCost = calculateMonthlyCost(Math.max(summary.avgVcpu - 1, 1));
    recommendations.push({
      type: 'downscale',
title: 'Reduce idle resources',
description: `Average CPU utilization is low at ${summary.avgUtilization.toFixed(0)}%. You can save money by reducing the minimum vCPU.`,
      currentCost,
      projectedCost,
      savingsPercent: Math.round(((currentCost - projectedCost) / currentCost) * 100),
      confidence: 0.7,
implementation: 'Keep minVcpu in ScalingConfig at 1 and adjust idle threshold based on current utilization.',
      risk: 'low',
    });
  }

// Recommend scheduling if there is enough data
  if (days >= 3 && summary.dataPointCount > 100) {
    const nightCost = calculateMonthlyCost(1);
    const dayCost = calculateMonthlyCost(2);
const scheduledCost = (nightCost * 10 + dayCost * 14) / 24; // 10 hours night, 14 hours day

    recommendations.push({
      type: 'schedule',
title: 'Time-based scheduling',
description: 'Optimizes costs by automatically adjusting to 1 vCPU at night (22:00-8:00) and 2 vCPU during the day.',
      currentCost,
      projectedCost: Math.round(scheduledCost * 100) / 100,
      savingsPercent: Math.round(((currentCost - scheduledCost) / currentCost) * 100),
      confidence: 0.6,
implementation: 'Set up a K8s CronJob to automatically adjust vCPUs based on time of day. Alternatively, you can use the AWS EventBridge scheduler.',
      risk: 'medium',
    });
  }

const insight = Analyzed ${summary.dataPointCount} data for `${days} days. ` +
`Average vCPU ${summary.avgVcpu}, peak ${summary.peakVcpu}, average CPU utilization ${summary.avgUtilization.toFixed(1)}%. ` +
`AI analysis failed, providing default recommendations`;

  return { recommendations, insight };
}

// ============================================================
// Main Export: Generate Cost Report
// ============================================================

/**
* Generate cost analysis report
 *
* @param days - Analysis period (default: 7, maximum: 30)
* @returns CostReport object
 *
 * @example
 * ```typescript
 * const report = await generateCostReport(7);
* console.log(`Total savings possible: ${report.totalSavingsPercent}%`);
 * ```
 */
export async function generateCostReport(days: number = 7): Promise<CostReport> {
// period limit
  const effectiveDays = Math.min(Math.max(days, 1), 30);

// data collection
  const patterns = analyzePatterns(effectiveDays);
  const summary = getUsageSummary(effectiveDays);
  const scalingHistory = getScalingHistory(50);

// calculate current cost
  const currentMonthly = calculateMonthlyCost(summary.avgVcpu);

// Generate AI recommendation
  const { recommendations, insight } = await getAIRecommendations(
    patterns,
    scalingHistory,
    summary,
    effectiveDays
  );

// Calculate optimization cost
  const optimizedMonthly = recommendations.length > 0
    ? Math.min(...recommendations.map(r => r.projectedCost))
    : currentMonthly;

// Calculate total savings
  const totalSavingsPercent = currentMonthly > 0
    ? Math.round(((currentMonthly - optimizedMonthly) / currentMonthly) * 100)
    : 0;

// Generate UUID (simple version)
  const id = `cost-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;

  return {
    id,
    generatedAt: new Date().toISOString(),
    currentMonthly,
    optimizedMonthly,
    totalSavingsPercent,
    recommendations,
    usagePatterns: patterns,
    aiInsight: insight,
    periodDays: effectiveDays,
  };
}
```

---

### 3.3 Create file: `src/app/api/cost-report/route.ts`

Cost Analysis API endpoint.

```typescript
/**
 * Cost Report API
* GET /api/cost-report - Create a cost analysis report
 */

import { NextResponse } from 'next/server';
import { generateCostReport } from '@/lib/cost-optimizer';

// set to dynamic route (disable caching)
export const dynamic = 'force-dynamic';

export async function GET(request: Request) {
  try {
    const url = new URL(request.url);
    const daysParam = url.searchParams.get('days');

// Default 7 days, maximum 30 days
    let days = 7;
    if (daysParam) {
      const parsed = parseInt(daysParam, 10);
      if (!isNaN(parsed) && parsed > 0) {
        days = Math.min(parsed, 30);
      }
    }

    console.log(`[Cost Report API] Generating report for ${days} days`);
    const startTime = Date.now();

    const report = await generateCostReport(days);

    console.log(`[Cost Report API] Report generated in ${Date.now() - startTime}ms`);

    return NextResponse.json(report, {
      headers: {
        'Cache-Control': 'no-store, no-cache, must-revalidate',
      },
    });
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    console.error('[Cost Report API] Error:', errorMessage);

    return NextResponse.json(
      {
        error: 'Failed to generate cost report',
        message: errorMessage,
      },
      { status: 500 }
    );
  }
}
```

---

## 4. Edit existing files

### 4.1 Fix: `src/app/api/metrics/route.ts`

Modified to record usage data in usage-tracker.

**Location:** Added to the import area at the top of the file

```typescript
// Existing imports...
import { createPublicClient, http } from 'viem';
import { mainnet, sepolia } from 'viem/chains';
import { NextResponse } from 'next/server';

// === Add ===
import { recordUsage } from '@/lib/usage-tracker';
```

**Location:** Inside the GET handler, after cost calculation (approximately between lines 420-425)

**Before:**
```typescript
        const currentHourlyCost = opGethMonthlyCost / HOURS_PER_MONTH;

        const response = NextResponse.json({
```

**After:**
```typescript
        const currentHourlyCost = opGethMonthlyCost / HOURS_PER_MONTH;

// === Add: Usage data recording ===
// Log only when not in stress test mode (collect only actual operational data)
        if (!isStressTest) {
          recordUsage(currentVcpu, effectiveCpu);
        }

        const response = NextResponse.json({
```

### 4.2 Fix: `src/app/page.tsx`

Added cost analysis UI.

**Location:** Add to import area

```typescript
// Existing imports...
import {
  Activity, Server, Zap, ShieldAlert, Cpu, ArrowUpRight,
  TrendingDown, FileText, CheckCircle2, XCircle, Shield
} from 'lucide-react';

// === Add ===
import { BarChart3, Calendar, Lightbulb, AlertTriangle, ChevronRight } from 'lucide-react';
```

**Location:** Add type under MetricData interface

```typescript
interface MetricData {
// ... existing code ...
}

// === Add: Cost Report Type ===
interface CostReportData {
  id: string;
  generatedAt: string;
  currentMonthly: number;
  optimizedMonthly: number;
  totalSavingsPercent: number;
  recommendations: Array<{
    type: 'downscale' | 'schedule' | 'reserved' | 'right-size';
    title: string;
    description: string;
    currentCost: number;
    projectedCost: number;
    savingsPercent: number;
    confidence: number;
    implementation: string;
    risk: 'low' | 'medium' | 'high';
  }>;
  usagePatterns: Array<{
    dayOfWeek: number;
    hourOfDay: number;
    avgVcpu: number;
    peakVcpu: number;
    avgUtilization: number;
    sampleCount: number;
  }>;
  aiInsight: string;
  periodDays: number;
}
```

**Location:** Added to the state declaration area in the Dashboard component

```typescript
export default function Dashboard() {
// Existing states...
  const [dataHistory, setDataHistory] = useState<{ name: string; cpu: number; gethVcpu: number; gethMemGiB: number; saving: number; cost: number }[]>([]);
  const [current, setCurrent] = useState<MetricData | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [stressMode, setStressMode] = useState(false);
  const [logInsight, setLogInsight] = useState<{ summary: string; severity: string; timestamp: string; action_item?: string } | null>(null);
  const [isAnalyzing, setIsAnalyzing] = useState(false);

// === Add: Cost Report state ===
  const [costReport, setCostReport] = useState<CostReportData | null>(null);
  const [isLoadingCostReport, setIsLoadingCostReport] = useState(false);
  const [showCostAnalysis, setShowCostAnalysis] = useState(false);
```

**Location:** Add new function under checkLogs function

```typescript
  const checkLogs = async (mode: string) => {
// ... existing code ...
  };

// === Add: cost analysis function ===
  const fetchCostReport = async () => {
    setIsLoadingCostReport(true);
    setCostReport(null);
    try {
      const res = await fetch('/api/cost-report?days=7');
      if (!res.ok) throw new Error('Failed to fetch cost report');
      const data = await res.json();
      setCostReport(data);
      setShowCostAnalysis(true);
    } catch (e) {
      console.error('Cost report error:', e);
    } finally {
      setIsLoadingCostReport(false);
    }
  };
```

**Location:** Replace “Total Saved Card (Dark)” in the Resource Center section.

**Before (whole area to replace - approximately lines 304-326):**
```typescript
          {/* Total Saved Card (Dark) */}
          <div className="mt-auto bg-[#1A1D21] rounded-2xl p-5 text-white">
            <div className="flex justify-between items-start mb-2">
              <span className="text-[10px] text-gray-400 font-semibold uppercase tracking-wider">
                {current?.cost.isPeakMode ? 'Cost Increase (Peak)' : 'Total Saved (MTD)'}
              </span>
              {current?.cost.isPeakMode
                ? <ArrowUpRight size={18} className="text-red-400" />
                : <TrendingDown size={18} className="text-green-400" />
              }
            </div>
            <div className="flex items-baseline gap-2">
              <span className="text-3xl font-black">
                ${Math.abs(current?.cost.monthlySaving || 124).toFixed(0)}
              </span>
              <span className={`text-sm font-bold ${current?.cost.isPeakMode ? 'text-red-400' : 'text-green-400'}`}>
                {current?.cost.isPeakMode ? '+' : '-'}{Math.abs((current?.cost.monthlySaving || 0) / (current?.cost.fixedCost || 166) * 100).toFixed(0)}%
              </span>
            </div>
            <p className="text-gray-400 text-xs mt-2 leading-relaxed">
              <span className="text-gray-300">vs Fixed 4 vCPU (${current?.cost.fixedCost?.toFixed(0) || '166'}/mo)</span> — {current?.cost.isPeakMode ? 'Scaling up to handle traffic spike.' : 'AI-driven scaling reduced Fargate costs.'}
            </p>
          </div>
```

**After (New Expansion Cost Dashboard):**
```typescript
          {/* Cost Dashboard (Dark) - Expanded */}
          <div className="mt-auto bg-[#1A1D21] rounded-2xl p-5 text-white">
            {/* Header with Cost Analysis Button */}
            <div className="flex justify-between items-start mb-3">
              <div>
                <span className="text-[10px] text-gray-400 font-semibold uppercase tracking-wider">
                  {current?.cost.isPeakMode ? 'Cost Increase (Peak)' : 'Total Saved (MTD)'}
                </span>
                <div className="flex items-baseline gap-2 mt-1">
                  <span className="text-3xl font-black">
                    ${Math.abs(current?.cost.monthlySaving || 124).toFixed(0)}
                  </span>
                  <span className={`text-sm font-bold ${current?.cost.isPeakMode ? 'text-red-400' : 'text-green-400'}`}>
                    {current?.cost.isPeakMode ? '+' : '-'}{Math.abs((current?.cost.monthlySaving || 0) / (current?.cost.fixedCost || 166) * 100).toFixed(0)}%
                  </span>
                </div>
              </div>
              <button
                onClick={fetchCostReport}
                disabled={isLoadingCostReport}
                className={`flex items-center gap-1.5 px-3 py-1.5 rounded-lg text-xs font-bold transition-all ${
                  isLoadingCostReport
                    ? 'bg-gray-700 text-gray-400 cursor-not-allowed'
                    : 'bg-blue-600 hover:bg-blue-500 text-white'
                }`}
              >
                {isLoadingCostReport ? (
                  <Activity className="animate-spin" size={12} />
                ) : (
                  <BarChart3 size={12} />
                )}
{isLoadingCostReport ? 'Analyzing...' : 'COST ANALYSIS'}
              </button>
            </div>

            <p className="text-gray-400 text-xs leading-relaxed">
              <span className="text-gray-300">vs Fixed 4 vCPU (${current?.cost.fixedCost?.toFixed(0) || '166'}/mo)</span> — {current?.cost.isPeakMode ? 'Scaling up to handle traffic spike.' : 'AI-driven scaling reduced Fargate costs.'}
            </p>

            {/* Cost Analysis Panel (Expandable) */}
            {showCostAnalysis && costReport && (
              <div className="mt-4 pt-4 border-t border-gray-700">
                {/* AI Insight */}
                <div className="mb-4 p-3 bg-blue-900/30 rounded-xl border border-blue-800/50">
                  <div className="flex items-start gap-2">
                    <Lightbulb size={14} className="text-blue-400 mt-0.5 shrink-0" />
                    <p className="text-xs text-blue-200 leading-relaxed">{costReport.aiInsight}</p>
                  </div>
                </div>

                {/* Usage Heatmap */}
                <div className="mb-4">
                  <div className="flex items-center gap-2 mb-2">
                    <Calendar size={12} className="text-gray-400" />
<span className="text-[10px] text-gray-400 font-semibold uppercase">Usage pattern (last {costReport.periodDays} days)</span>
                  </div>
                  <UsageHeatmap patterns={costReport.usagePatterns} />
                </div>

                {/* Recommendations */}
                {costReport.recommendations.length > 0 && (
                  <div>
                    <div className="flex items-center justify-between mb-2">
<span className="text-[10px] text-gray-400 font-semibold uppercase">Optimization recommendation</span>
<span className="text-[10px] text-green-400 font-bold">Savings up to {costReport.totalSavingsPercent}%</span>
                    </div>
                    <div className="space-y-2">
                      {costReport.recommendations.slice(0, 3).map((rec, idx) => (
                        <RecommendationCard key={idx} recommendation={rec} />
                      ))}
                    </div>
                  </div>
                )}

                {/* Close Button */}
                <button
                  onClick={() => setShowCostAnalysis(false)}
                  className="w-full mt-3 py-2 text-xs text-gray-400 hover:text-gray-300 transition-colors"
                >
close
                </button>
              </div>
            )}
          </div>
```

**Location:** End of file, add new component below LogBlock component

```typescript
function LogBlock({ time, source, level, msg, highlight, color }: { time: string; source: string; level: string; msg: string; highlight?: boolean; color?: string }) {
// ... existing code ...
}

// === Add: Usage Heatmap component ===
function UsageHeatmap({ patterns }: { patterns: CostReportData['usagePatterns'] }) {
const days = ['Sun', 'Mon', 'Tues', 'Wed', 'Thu', 'Fri', 'Sat'];
  const hours = Array.from({ length: 24 }, (_, i) => i);

// Convert pattern data to 2D map
  const patternMap = new Map<string, { avgVcpu: number; avgUtilization: number }>();
  patterns.forEach(p => {
    patternMap.set(`${p.dayOfWeek}-${p.hourOfDay}`, {
      avgVcpu: p.avgVcpu,
      avgUtilization: p.avgUtilization,
    });
  });

// Determine color based on usage
  const getColor = (utilization: number): string => {
    if (utilization === 0) return 'bg-gray-800';
    if (utilization < 20) return 'bg-green-900/60';
    if (utilization < 40) return 'bg-green-700/60';
    if (utilization < 60) return 'bg-yellow-700/60';
    if (utilization < 80) return 'bg-orange-700/60';
    return 'bg-red-700/60';
  };

  return (
    <div className="overflow-x-auto">
      <div className="min-w-[400px]">
        {/* Hour labels */}
        <div className="flex ml-6 mb-1">
          {[0, 4, 8, 12, 16, 20].map(h => (
            <div key={h} className="text-[8px] text-gray-500 font-mono" style={{ marginLeft: h === 0 ? 0 : 'calc((100% - 48px) / 6 - 8px)', width: '16px' }}>
{h}hour
            </div>
          ))}
        </div>

        {/* Grid */}
        <div className="space-y-0.5">
          {days.map((day, dayIdx) => (
            <div key={day} className="flex items-center gap-1">
              <span className="w-5 text-[9px] text-gray-500 font-medium">{day}</span>
              <div className="flex-1 flex gap-px">
                {hours.map(hour => {
                  const data = patternMap.get(`${dayIdx}-${hour}`);
                  const utilization = data?.avgUtilization || 0;
                  const vcpu = data?.avgVcpu || 0;

                  return (
                    <div
                      key={hour}
                      className={`flex-1 h-3 rounded-sm ${getColor(utilization)} transition-colors hover:ring-1 hover:ring-white/30`}
title={`${days[dayIdx]} ${hour}:00 - 평균 ${vcpu.toFixed(1)} vCPU, ${utilization.toFixed(0)}% 사용률`}
                    />
                  );
                })}
              </div>
            </div>
          ))}
        </div>

        {/* Legend */}
        <div className="flex items-center justify-end gap-2 mt-2">
<span className="text-[8px] text-gray-500">낮음</span>
          <div className="flex gap-px">
            <div className="w-3 h-2 rounded-sm bg-green-900/60" />
            <div className="w-3 h-2 rounded-sm bg-green-700/60" />
            <div className="w-3 h-2 rounded-sm bg-yellow-700/60" />
            <div className="w-3 h-2 rounded-sm bg-orange-700/60" />
            <div className="w-3 h-2 rounded-sm bg-red-700/60" />
          </div>
<span className="text-[8px] text-gray-500">높음</span>
        </div>
      </div>
    </div>
  );
}

// === Add: Recommendation Card component ===
function RecommendationCard({ recommendation }: { recommendation: CostReportData['recommendations'][0] }) {
  const [expanded, setExpanded] = useState(false);

  const riskStyles = {
low: { bg: 'bg-green-900/30', text: 'text-green-400', label: '낮음' },
medium: { bg: 'bg-yellow-900/30', text: 'text-yellow-400', label: '중간' },
high: { bg: 'bg-red-900/30', text: 'text-red-400', label: '높음' },
  };

  const typeIcons = {
    downscale: TrendingDown,
    schedule: Calendar,
    reserved: Shield,
    'right-size': BarChart3,
  };

  const Icon = typeIcons[recommendation.type] || BarChart3;
  const risk = riskStyles[recommendation.risk];

  return (
    <div
      className={`p-3 rounded-xl border border-gray-700/50 bg-gray-800/30 cursor-pointer transition-all hover:bg-gray-800/50`}
      onClick={() => setExpanded(!expanded)}
    >
      <div className="flex items-start justify-between">
        <div className="flex items-start gap-2">
          <Icon size={14} className="text-blue-400 mt-0.5 shrink-0" />
          <div>
            <p className="text-xs font-bold text-white">{recommendation.title}</p>
            <p className="text-[10px] text-gray-400 mt-0.5">{recommendation.description}</p>
          </div>
        </div>
        <div className="flex items-center gap-2 shrink-0">
<span className="text-xs font-bold text-green-400">-${(recommendation.currentCost - recommendation.projectedCost).toFixed(0)}/월</span>
          <ChevronRight size={14} className={`text-gray-500 transition-transform ${expanded ? 'rotate-90' : ''}`} />
        </div>
      </div>

      {expanded && (
        <div className="mt-3 pt-3 border-t border-gray-700/50">
          {/* Stats */}
          <div className="grid grid-cols-3 gap-2 mb-3">
            <div className="text-center">
<p className="text-[9px] text-gray-500 uppercase">Current cost</p>
              <p className="text-xs font-bold text-white">${recommendation.currentCost.toFixed(0)}</p>
            </div>
            <div className="text-center">
<p className="text-[9px] text-gray-500 uppercase">Estimated cost</p>
              <p className="text-xs font-bold text-green-400">${recommendation.projectedCost.toFixed(0)}</p>
            </div>
            <div className="text-center">
<p className="text-[9px] text-gray-500 uppercase">절감률</p>
              <p className="text-xs font-bold text-green-400">{recommendation.savingsPercent}%</p>
            </div>
          </div>

          {/* Risk & Confidence */}
          <div className="flex items-center gap-3 mb-3">
            <div className={`px-2 py-0.5 rounded text-[9px] font-bold ${risk.bg} ${risk.text}`}>
Risk: {risk.label}
            </div>
            <div className="text-[9px] text-gray-400">
Confidence: {(recommendation.confidence * 100).toFixed(0)}%
            </div>
          </div>

          {/* Implementation */}
          <div className="p-2 bg-gray-900/50 rounded-lg">
<p className="text-[9px] text-gray-400 uppercase mb-1">Implementation method</p>
            <p className="text-[10px] text-gray-300 leading-relaxed">{recommendation.implementation}</p>
          </div>
        </div>
      )}
    </div>
  );
}
```

---

## 5. API Specification

### 5.1 GET /api/cost-report

Generate cost analysis reports.

**Query Parameters:**

| parameters | Type | Required | default | Description |
|----------|------|------|--------|------|
| days | number | No | 7 | Analysis period (1-30 days) |

**Request Example:**
```bash
curl "http://localhost:3002/api/cost-report?days=7"
```

**Response (200 OK):**
```json
{
  "id": "cost-1707235200000-abc123",
  "generatedAt": "2026-02-06T15:00:00.000Z",
  "currentMonthly": 62.45,
  "optimizedMonthly": 48.32,
  "totalSavingsPercent": 23,
  "recommendations": [
    {
      "type": "schedule",
"title": "Reduce Nighttime Resources",
"description": "Traffic drops by 60% compared to average between 22:00 and 08:00. You can save money by operating with 1 vCPU during these times.",
      "currentCost": 62.45,
      "projectedCost": 48.32,
      "savingsPercent": 23,
      "confidence": 0.85,
"implementation": "Set up a K8s CronJob to call the scaler API at 22:00 to scale down to 1 vCPU and restore to 2 vCPU at 08:00. Alternatively, you can automate it using a combination of the AWS EventBridge scheduler and Lambda.",
      "risk": "low"
    },
    {
      "type": "right-size",
"title": "Average Utilization Based Optimization",
"description": "Current average CPU utilization is low at 25%. You can adjust the scaling threshold to avoid unnecessary scale-ups.",
      "currentCost": 62.45,
      "projectedCost": 51.20,
      "savingsPercent": 18,
      "confidence": 0.72,
"implementation": "In DEFAULT_SCALING_CONFIG in scaling-decision.ts, adjust thresholds.idle from 30 to 40 and thresholds.normal from 70 to 80.",
      "risk": "medium"
    }
  ],
  "usagePatterns": [
    {
      "dayOfWeek": 0,
      "hourOfDay": 0,
      "avgVcpu": 1.2,
      "peakVcpu": 2,
      "avgUtilization": 15.5,
      "sampleCount": 42
    },
    {
      "dayOfWeek": 0,
      "hourOfDay": 1,
      "avgVcpu": 1.1,
      "peakVcpu": 1,
      "avgUtilization": 12.3,
      "sampleCount": 38
    }
  ],
"aiInsight": "Analyzing usage patterns over the past 7 days, we see a pattern of significantly reduced traffic during nighttime hours (22:00 - 08:00) and on weekends. Average usage of 1.3 vCPU, maximum of 4 vCPU, and average CPU utilization of 28%. Applying time-based scheduling can result in cost savings of approximately $14 per month.",
  "periodDays": 7
}
```

**Error Response (500 Internal Server Error):**
```json
{
  "error": "Failed to generate cost report",
  "message": "AI Gateway responded with 503: Service Unavailable"
}
```

---

## 6. AI Prompt Professional

### 6.1 System Prompt (Full text)

```
You are a cloud cost optimization advisor for an Optimism L2 Rollup infrastructure running on AWS Fargate.

## Your Role
Analyze vCPU usage patterns and scaling history to identify cost optimization opportunities.

## Infrastructure Context
- Platform: AWS Fargate (Seoul Region: ap-northeast-2)
- Pricing:
  - vCPU: $0.04656 per hour
  - Memory: $0.00511 per GB-hour
  - Memory allocation: vCPU * 2 GiB (e.g., 2 vCPU = 4 GiB)
- vCPU Range: 1-4 vCPU (dynamic scaling)
- Baseline comparison: Fixed 4 vCPU = ~$166/month

## Optimism L2 Workload Characteristics
- Batcher submits batches every 2-5 minutes
- Sequencer produces blocks every 2 seconds
- Traffic patterns: typically lower on weekends and night hours (KST)
- Peak hours: weekday business hours (9am-6pm KST)

## Recommendation Types
1. **downscale**: Reduce max vCPU or adjust idle thresholds
2. **schedule**: Time-based scaling (e.g., 1 vCPU at night, 2 vCPU during day)
3. **reserved**: Compare with Savings Plans or Reserved Capacity
4. **right-size**: Adjust current allocation based on actual usage

## Response Requirements
- All text descriptions should be in Korean
- Be specific about implementation steps
- Include risk assessment for each recommendation
- Calculate exact USD savings based on provided pricing

Respond ONLY in valid JSON format without markdown code blocks.
```

### 6.2 User Prompt Template (Full text)

```
## Analysis Period
{days} days of usage data, {dataPointCount} data points collected.

## Usage Summary
- Average vCPU: {avgVcpu}
- Peak vCPU: {peakVcpu}
- Average CPU Utilization: {avgUtilization}%

## Current Monthly Cost (based on average)
${currentMonthlyCost}/month

## Baseline Comparison (Fixed 4 vCPU)
${baselineCost}/month

## Time-based Usage Patterns (Day x Hour)
[
  { "day": "Mon", "hour": 9, "avgVcpu": 2.1, "peakVcpu": 4, "utilization": 67.5, "samples": 28 },
  { "day": "Mon", "hour": 10, "avgVcpu": 2.3, "peakVcpu": 4, "utilization": 72.1, "samples": 31 },
  ...
]

## Recent Scaling Events
[
  { "time": "2026-02-06T10:30:00Z", "from": 1, "to": 2, "reason": "Normal Load Detected", "trigger": "auto" },
  { "time": "2026-02-06T14:15:00Z", "from": 2, "to": 4, "reason": "High Load Detected", "trigger": "auto" },
  ...
]

## Instructions
Analyze the above data and provide cost optimization recommendations.

For each recommendation, include:
1. type: 'downscale' | 'schedule' | 'reserved' | 'right-size'
2. title: Recommended title (Korean, within 20 characters)
3. description: Detailed description (Korean, within 100 characters)
4. currentCost: Current monthly cost (USD)
5. projectedCost: Estimated monthly cost after application (USD)
6. savingsPercent: savings percentage (0-100)
7. confidence: confidence (0-1)
8. implementation: implementation method (Korean, in detail)
9. risk: 'low' | 'medium' | 'high'

Also provide an overall insight summary in Korean.

Respond in this exact JSON format:
{
  "recommendations": [
    {
      "type": "schedule",
      "title": "...",
      "description": "...",
      "currentCost": 123.45,
      "projectedCost": 98.76,
      "savingsPercent": 20,
      "confidence": 0.85,
      "implementation": "...",
      "risk": "low"
    }
  ],
"insight": "Full Insight Summary (Korean)"
}
```

### 6.3 Expected AI Response Format

```json
{
  "recommendations": [
    {
      "type": "schedule",
"title": "Night Automatic Scale Down",
"description": "Traffic decreases by 65% ​​compared to average between 22:00 and 08:00. Cost savings can be achieved by operating with 1 vCPU during these hours.",
      "currentCost": 62.45,
      "projectedCost": 48.32,
      "savingsPercent": 23,
      "confidence": 0.88,
"implementation": "K8s CronJob 2개를 생성합니다:\n1. 22:00 KST - POST /api/scaler {targetVcpu: 1}\n2. 08:00 KST - POST /api/scaler {targetVcpu: 2}\n\nCronJob YAML 예시:\n```yaml\napiVersion: batch/v1\nkind: CronJob\nmetadata:\n  name: scale-down-night\nspec:\n  schedule: \"0 22 * * *\"\n  jobTemplate:\n    spec:\n      template:\n        spec:\n          containers:\n          - name: scaler\n            image: curlimages/curl\n            command: [\"curl\", \"-X\", \"POST\", \"http://sentinai:3000/api/scaler\", \"-d\", '{\"targetVcpu\":1}']\n```",
      "risk": "low"
    },
    {
      "type": "right-size",
"title": "Scaling Threshold Optimization",
"description": "The average utilization rate is 28%, which is near the idle threshold (30). Raising the threshold can prevent unnecessary scale-up.",
      "currentCost": 62.45,
      "projectedCost": 55.10,
      "savingsPercent": 12,
      "confidence": 0.72,
"implementation": "Modify DEFAULT_SCALING_CONFIG in src/types/scaling.ts:\n\nBefore:\nthresholds: { idle: 30, normal: 70 }\n\nAfter:\nthresholds: { idle: 40, normal: 80 }\n\nThis will keep it at 1 vCPU only when score is below 40, and 80 Scales up to 4 vCPU only when there is more.",
      "risk": "medium"
    }
  ],
"insight": "After analyzing 1,440 pieces of data over 7 days, we see a pattern of significantly reduced traffic at night (22:00 - 08:00) and on weekends. Currently, with an average of 1.3 vCPU and an average utilization of 28%, resources are available. Applying time-based scheduling alone can save $14 (23%) per month, and applying threshold adjustment together can save up to $18 (29%). The risk is low; There will be no impact on peak hour performance."
}
```

---

## 7. Environment variables

### 7.1 New environment variables

Add to `.env.local.sample`:

```bash
# Cost Optimizer (Proposal 4)
# Whether to enable usage tracking (default: true)
# If set to false, no usage data will be collected
COST_TRACKING_ENABLED=true
```

### 7.2 Existing environment variables (required)

This feature uses your existing AI Gateway settings:

```bash
# AI Configuration (Required for Cost Analysis)
AI_GATEWAY_URL=https://api.ai.tokamak.network
ANTHROPIC_API_KEY=your-api-key-here
```

---

## 8. Test verification

### 8.1 API testing (curl)

**Create basic report:**
```bash
curl -X GET "http://localhost:3002/api/cost-report" | jq
```

**14-day analysis:**
```bash
curl -X GET "http://localhost:3002/api/cost-report?days=14" | jq
```

**Response confirmation items:**
- `id`: Is a unique ID created?
- `recommendations`: Is there at least 1 recommendation?
- `usagePatterns`: If data exists, check whether it contains patterns.
- `aiInsight`: Is the insight written in Korean?

### 8.2 UI testing

**Scenario 1: Steady Flow**
1. Access dashboard (`http://localhost:3002`)
2. Click the “COST ANALYSIS” button at the bottom of the Resource Center
3. Check the loading spinner display
4. After analysis is complete:
- Display AI insight card
- Show usage pattern heatmap
- Display list of recommended cards
5. Expand detailed information when clicking on the recommended card
6. Collapse the panel with the “Close” button

**Scenario 2: No data**
1. Immediately after server restart (no data)
2. Click the “COST ANALYSIS” button
3. Verify that Fallback recommendations are displayed
4. Check the message “AI analysis failed, providing default recommendations”

**Scenario 3: Excluding stress mode**
1. Click the “Simulate Load” button to activate stress mode
2. Wait 1-2 minutes (data collection)
3. Disable stress mode
4. Run “COST ANALYSIS”
5. Verify that 8 vCPU data is not included in the pattern

### 8.3 Edge Cases

| case | Expected Behavior |
|--------|-----------|
| 0 usage data | Empty Pattern, Fallback Insights |
| Only 1-match data exists | Limited pattern, low confidence recommendation |
| AI Gateway timeout | Fallback recommendation generation, error logging |
| Invalid days parameter | Use default 7 days |
| days > 30 | Limited to 30 days |

---

## 9. Dependencies

### 9.1 Required dependencies

| module | Description | status |
|------|------|------|
| `src/lib/k8s-scaler.ts` | `getScalingHistory()` function | already exists |
| AI Gateway | Claude API call | Existing pattern exists |

### 9.2 Optional dependencies (Proposal 1)

Once `MetricsStore` is implemented, it can be integrated by extending `usage-tracker.ts`:

```typescript
// example of future expansion
import { getStats } from '@/lib/metrics-store';

export function enhancedPatternAnalysis(days: number) {
  const usagePatterns = analyzePatterns(days);
  const metricsStats = getStats(days * 24 * 60, 'cpuUsage'); // Proposal 1

  return {
    patterns: usagePatterns,
    trend: metricsStats.trend, // 'rising' | 'falling' | 'stable'
  };
}
```

### 9.3 Independence

- **Proposal 2 (Anomaly Detection):** Independent, separate function
- **Proposal 3 (RCA Engine):** Independent, separate function
- **Proposal 5 (NLOps):** Independent, possible integration in the future

---

## 10. UI Details - Usage Heatmap

### 10.1 Layout Specification

**structure:**
- 7 rows (Sunday - Saturday) x 24 columns (00:00 - 23:00) grid
- Each cell: 3px height, flex-1 width
- Day label: left 20px wide
- Time labels: 6 hour intervals at the top (0, 4, 8, 12, 16, 20)

**Color scale (based on CPU utilization):**

| utilization | color class | Description |
|--------|-------------|------|
| 0% | `bg-gray-800` | No data |
| 1-19% | `bg-green-900/60` | very low |
| 20-39% | `bg-green-700/60` | low |
| 40-59% | `bg-yellow-700/60` | Normal |
| 60-79% | `bg-orange-700/60` | High |
| 80%+ | `bg-red-700/60` | very high |

### 10.2 Interaction

**Hover Tooltip:**
```
14:00 per month - 2.1 vCPU average, 67% utilization
```

**Implementation (using title attribute):**
```tsx
title={`${days[dayOfWeek]} ${hour}:00 - 평균 ${vcpu.toFixed(1)} vCPU, ${utilization.toFixed(0)}% 사용률`}
```

### 10.3 Consider responsiveness

- `min-w-[400px]`: Guaranteed minimum width
- `overflow-x-auto`: horizontal scrolling on small screens
- Horizontal scroll hint can be displayed on mobile devices

---

## Implementation Checklist

Items to check after implementation is complete:

- [ ] Create `src/types/cost.ts` and define all types
- [ ] `src/lib/usage-tracker.ts` creation and function implementation
- [ ] Creation of `src/lib/cost-optimizer.ts` and integration with AI
- [ ] Create `src/app/api/cost-report/route.ts`
- [ ] Add `recordUsage` call to `src/app/api/metrics/route.ts`
- [ ] Add state, function, and UI components to `src/app/page.tsx`
- [ ] Add `COST_TRACKING_ENABLED` to `.env.local.sample`
- [ ] No TypeScript compilation errors (`npm run build`)
- [ ] No ESLint warnings (`npm run lint`)
- [ ] Local testing completed (curl, UI)

---

## end of document

This document is the complete implementation specification for Proposal 4: AI Cost Optimizer.
It can be implemented using only this document without reference to other files or external documents.

Created on: 2026-02-06
Version: 1.0.0
