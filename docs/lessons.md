# Lessons Learned

## 2026-02-20

- 체인 플러그인이 추가되어도 레지스트리가 환경 변수 기반 선택을 하지 않으면 실제 운영에서 신규 플러그인이 절대 활성화되지 않는다.
  - 규칙: 새 플러그인 추가 시 `registry`의 선택 분기(`CHAIN_TYPE`)와 대응 테스트를 같은 변경셋에 포함한다.
- OP Stack 계열 체인은 컴포넌트/의존성/플레이북이 대부분 동일하다.
  - 규칙: 체인별 차이는 `chain metadata(l1/l2 chain, display name, chain id)`에 집중하고, 공통 토폴로지는 재사용해 중복을 줄인다.
- 복잡한 API 라우트는 유닛 목킹보다 실제 HTTP 스모크 경로가 회귀를 빨리 잡는다.
  - 규칙: `/api/*` 핵심 엔드포인트는 최소 1개는 서버 기동 + 실제 curl 검증 스크립트를 유지한다.
- 설치 스크립트가 새 기능을 모르면 런타임 지원이 있어도 운영자가 설정할 수 없다.
  - 규칙: 체인/오케스트레이터 같은 상위 선택지가 추가되면 `install.sh` 프롬프트, 비대화식 env 검증, `.env.local` 출력을 함께 업데이트한다.

## 2026-02-19

- 대시보드 카드에 리스트형 데이터가 누적되면 카드 자체가 늘어나 레이아웃이 무너진다.
  - 규칙: 로그/컴포넌트처럼 증분 데이터는 카드 높이를 고정하고 내부 영역에만 `overflow-y-auto`를 적용한다.
- flex 레이아웃에서 오른쪽 텍스트 영역이 남는 공간을 다 쓰지 못하면 예상보다 빠르게 줄바꿈된다.
  - 규칙: 상세 텍스트 영역은 `flex-1 min-w-0`를 명시하고, 주변 배지는 `shrink-0`/`min-w-0`를 분리해 실제 가용폭을 최대화한다.
- 단일 행 로그에서 좌측 고정폭 컬럼이 많으면 우측 분석 텍스트가 구조적으로 압축된다.
  - 규칙: 우측 영역 확보가 필요하면 좌측 컬럼 폭부터 축소하고, 보조 아이콘은 별도 컬럼 대신 우측 메타 영역 안으로 합친다.
- 로그 UI에서 공간 활용이 우선이면 고정 컬럼 정렬보다 `flex-wrap` 기반의 유동 행이 더 안정적이다.
  - 규칙: 정렬 일관성보다 가독성과 정보 밀도가 중요할 때는 줄 단위 유동 레이아웃을 기본으로 선택한다.
- seed 시나리오 TTL이 agent-loop 주기보다 짧으면 주입 부하가 스케일링 루프에 반영되지 않을 수 있다.
  - 규칙: 검증용 seed TTL은 agent-loop 주기 이상으로 유지하고, seed API TTL과 상태 저장소 TTL을 동일하게 맞춘다.
- seed 데이터의 `currentVcpu`는 관측용일 수 있어 실행 결정에 그대로 쓰면 오판이 생긴다.
  - 규칙: auto-scaling 실행 판단의 `currentVcpu`는 실제 런타임 상태(k8s/scaler state) 기준으로 계산한다.

## 2026-02-16

- 분기 로직에서 공통 변수 재초기화는 상위 분기 값을 쉽게 덮어쓴다.
  - 규칙: `seed/live`처럼 의미가 다른 경로는 계산 함수를 분리하고, 공유 변수 재할당을 최소화한다.
- 타입 단언(`as`)으로 런타임 계약을 축소하면 결함이 숨겨진다.
  - 규칙: 스케일링 tier 같은 핵심 도메인은 공통 타입 별칭을 만들고 전 구간에서 동일 타입을 사용한다.
- 동일한 외부 RPC 호출 패턴은 타임아웃/재시도 정책을 통일해야 한다.
  - 규칙: API/agent-loop 모두 공통 fetch 유틸 또는 동일 타임아웃 정책을 강제한다.
- 관측 API의 메타데이터(`source`)는 실제 데이터 경로(seed/live)와 반드시 일치해야 한다.
  - 규칙: 응답 필드는 하드코딩하지 말고, 분기 결과에서 파생된 값을 단일 변수로 설정한다.
- 인증 면제 경로는 접두사 매칭보다 정확 경로 매칭이 안전하다.
  - 규칙: 민감한 미들웨어 예외는 `startsWith` 대신 exact allowlist를 기본값으로 사용한다.
